<?php

//1、写一段代码，实现PHP内部的通知机制，如当一个类的属性发生变化时，另外一个类就可以收到通知(如提供两种及以上思路，可加分)

//1)可利用观察者模式

interface Subject{
	public function attach( Observer $observer ) ; // 注册观察者
	public function detach( Observer $observer ) ; // 删除观察者

	public function post() ; // 举例的事件，发自拍通知

	public function notify() ; // 通知广播
}

interface Observer{
	public function update() ; // 通知后的响应
}

class ConcreteSubject implements Subject{
	private $__observers ; // 被观察者中的观察者数组
	private $_message ;
	private $_me ;

	public function __construct( $me ,  $message ){
		$this->__observers = array() ;
		$this->_me = $me ;
		$this->_message = $message ;
	}

	public function attach( Observer $observer ){
		$this->__observers[] = $observer ; 
	}

	public function detach( Observer $observer ){
		$i = array_search( $observer , $this->__observers , true ) ;
		if( $i !== false ){
			unset( $this->__observers[$i] ) ;
		}
		return true ;
	}

	public function post(){
		echo "{$this->_me} just post a selfie with message " . $this->_message . '<br/>' ;
		$this->notify() ;
	}

	public function notify(){ 
		if( !is_array( $this->__observers ) ){
			return false ;
		}

		foreach( $this->__observers as $observer ){
			$observer->update() ;
		}
	}

}



class ConcreteObserver implements Observer{
	private $_name ;

	public function __construct( $name ){
		$this->_name = $name ;
	}

	public function update(){ // 响应函数
		echo 'Observer ' . $this->_name . ' just like the moments<br/>' ;
	}
}

//被观察者
$jenny = new ConcreteSubject("Jenny","Gone with the wind") ;
//观察者
$john   = new ConcreteObserver('John') ;
$steven = new ConcreteObserver('Steven') ;

$jenny->attach( $john ) ;
$jenny->attach( $steven ) ;
//$jenny->detach( $john ) ;
$jenny->post() ;








//2.以下代码会输出结果吗？如果不能请说明原因，并列举出三种可以使其输出结果的方式

私有变量不能被对象在类外部直接调用。
调用它的几种方法

1.构造方法 2.手动建可访问的方法，方法内调用私有变量 3.魔术方法__set( $propertyName , $value ),__get($propertyName)


3、看代码回答问题

//答案我写在注释
$a = 1;

function func( &amp;$a ){

echo $a;

$a = 100;

}

func($a); // 1

echo $a; // 100

class A{

public $a = 10;

}

$obj = new A();

func($obj->a);// 10

echo $obj->a;// 100


//4、如何解决或降低缓存服务的单点故障导致数据库的流量井喷
 //资源文件请求优化 , CDN , 缓存 , 分布式机器/dns轮循(我觉得这个关键，避免单台服务器压力过大) , 负载均衡..


/*5、设计一个数据库表，实现评论楼盖楼效果，并写出sql语句

a、写出建表语句

b、查询一个评论的所有子评论

c、写出每次新增和删除的sql语句

d、写出计算层级深度的sql语句*/

create table comments(
id int(11) unsigned not null primary key auto_increment ,
rootid int(11) unsigned default 0 ,
path varchar(255) not null , 
msg varchar(255) not null default '' ,
time datetime not null,
uid int(11) unsigned not null default 0 , 
uname char(200) not null default '' ,
...
...
index(path)
);
//b、查询一个评论的所有子评论
$id = 1 ; // 查询的某条评论的id
$sql = "select id,rootid,path,msg,time from comments where path like '/{$id}/%' ";

//c、写出每次新增和删除的sql语句
//新增
//假设前台 每一条评论 应该输出这些数据 可以储存在每一条评论html元素(比如li)的data-rootid,data-reid里，以供评论时ajax取值请求
$rootid = 2 ;
$reid = 40 ; // 欲回复的评论的id
$reid_path = '/2/15/40/' ;
$time = time() ;
$sql = "insert into comments(rootid,path,msg,time) values('".$rootid".','".$reid_path."','".$msg."','".$time."')";
//删除评论
$id = 43 ; // 欲删除的评论id及它的子评论 
$sql = "delete from comments where id = $id ";
$sql = "delete from comments where path like '/43/%'" ;  

//d、写出计算层级深度的sql语句*/
$id = 99 ; // 欲查找的评论id
$sql = "select path from comments where id = {$id}";
$path = '/2/32/57/66/79/' ;
//取出后 用php来计算
$level = substr_count( $path , '/' ) ;


// 6.
可以根据被关注者follow_uid与关注者uid分别分成粉丝表和关注表 字段可以不变
比如分成128张小表
粉丝表 follow_uid % 128 + 1 = 粉丝表编号 ，如fans_1 ,fans_2 ...  fans_128
关注表 uid % 128 + 1 = 关注表编号 , 如follow_who_1 follow_who_2 ... follow_128

查找一个人(已知$uid)的粉丝 就是 查找粉丝表
function get_fans_table_name($uid){
	$fans_table_name = 'fans_' . $uid % 128 + 1 ;
	return $fans_table_name ;
}
$fans_table_name = get_fans_table_name($uid) ;
$sql = "select uid from {$fans_table_name} where follow_uid = {$uid}";

查找一个人(已知$uid)的关注者，就是查找关注表
$follow_table_name = get_follow_table_name($uid) ; //类似上面规则计算出表名
$sql = "select follow_uid from {$follow_table_name} where uid = {$uid} ";

互粉状态
查找某人(已知$uid) 的互粉好友
从关注表中取得全部关注者的follow_uids , 然后放到查粉丝的语句当中来找(fans_uids)，也是上面2句，
查粉丝的这一句要加下id in ;
$sql = "select uid from {$fans_table_name} where follow_uid = {$uid} and uid in ({$follow_uids}) " ;
取得的结果集就是互粉好友

对其他某个单独用户判断与当前此用户的好友关系，可以根据上面2个语句in语法,in换成这个单独用户的uid，根据结果集是否为空或者有值，可以区分出单向还是互粉或者被关注。

上面是基本思路。

现在知道了目标：将原始大表及新增信息，完全地迁移到上述的小表当中。

具体在线分表如何操作的话，就是原大表不再修改，再增加1个扩张表（字段不变），2个取关表（对应原始大表的记录的取关，结构可以与原始大表一样，但不再代表关注，而代表取关），
线上程序的查询状态 就根据 1.原始大表 2.扩张表（新增关注状态） 3.取关表 来联合查询
2个取关表的意义是，其中1个表（只增记录不减记录）用来提供旧程序的线上查询服务，另1个表（会有删记录的操作）用于迁移配合剔除大表记录用。

程序增加逻辑，对用户的新操作（关注行为，而且一定是新关注，新关注并取消的，应该在扩张表中立刻删除记录，同时也删除新分小表中的记录）进行记录，
将这些新行为记录到新分小表（此时新分小表仅仅是保存着新关注行为，线上的查询也并未依赖新分小表）

取关表的取关行为也可以做一个通知，冗余地删除新分小表中的记录（但不会删除任何结果，因为新分小表此时皆为新关注记录），这么做是为了后面大表移进小表之后，
保证数据的准确性
如果删除成功( mysql_affected_rows() == 1 ) 这时候也要删掉对应的取关表中的这条记录
没有删除的话，这条取关表记录不作处理。

找1个半夜用户访问低下的时候，开始对原始大表进行处理，分别处理到上述新分小表中，
对原始大表的处理，要剔除取关表中的数据（之后也删除处理过的取关表的记录）
完成后，再对新分小表 根据 取关表中的信息（存在的都是要取关的，会什么会有存在的记录，因为是线上服务，处理进小表的都已经删除了） 处理一遍，（这里也可以写成定时程序，如果上面有冗余删除的话就不用）
完成后，大表就已经完整迁移到小表中。

之后的线上服务，小表已经存着准确记录，可以修改程序逻辑到读小表。

总结就是：

1.分表，增加程序逻辑，记录新增记录到小表
2.迁移原始大表（具体步骤参考上面）
3.修改程序逻辑读小表，并去掉之前为迁移而增加的多余逻辑
4.完成
不好的地方是表变成2张（粉丝，关注者），每次需要多存/写1条记录（原来是1条），空间*2 。



7.涉及海量数据的写入与存储，应该在功能上尽可能地细化功能，分别处理，可以设置分布式的一批HTTP服务器来专门作日志收集工作，另一批服务器专门作存储，收集服务器按一定周期向存储服务器写入日志，
要考虑稳定性，扩展能力，系统监控等等。因为海量数据带来大来读写，大量读写还带来了传输上的问题。这个问题我不是特别有经验，实施起来对运维和架构能力要求比较高。

参考http://tech.meituan.com/mt-log-system-arch.html





